# coding: utf-8
import math

NB_SELLING_SESSIONS = 12
MAX_PRICE = 120
MIN_PRICE = 80
expected_values = {}
price_limits = {}

"""
Convention 1: since we're working with integers, equalities are likely and annoying to specify on every calculation. 
We will take action a guaranteed action (sell of buy) has the exact same value as going into the next session, we will always prefer
taking the saif action.

Convention 2: since it's more profitable to bulk buy/sell, we'll assume we're buying/selling only 1 turnip.
This is just a simplification to avoid trailing a NUMBER_OF_TURNIPS variable everywhere.
"""


def proba_of_price(price):
    return 1.0 / (MAX_PRICE - MIN_PRICE)


def sum_of_probas_from_price_to_price(starting_price, ending_price):
    """Returns the probability of a random price being between inclusive
    starting_price and inclusive ending_price.

    Prices are integers.
    """
    sum = 0
    for i in range(int(starting_price), int(ending_price + 1)):
        sum += proba_of_price(i)
    return sum


def expected_sell_from_price_to_price(starting_price, ending_price):
    """Returns the expected value of the sell if the price is between inclusive
    starting_price and inclusive ending_price.

    Prices are integers.
    """
    sum = 0
    for i in range(int(starting_price), int(ending_price + 1)):
        sum += proba_of_price(i) * i
    return sum


def calculate_selling_session(selling_session):
    print("Calculating selling session number {}".format(selling_session))
    if selling_session == 12:
        print("This is the last selling session, we must sell no matter what")
        expected_values[selling_session] = expected_sell_from_price_to_price(
            MIN_PRICE, MAX_PRICE
        )
        # Expected value = selling value here "price_limits" are the equivalent selling prices that would make selling and waiting equivalent,
        # expected value wise, for a given session. These price_limits are lower on the last sessions and higher on the first sessions.
        # Intuitively this means that we can afford rolling the dice more often when we have lots of turns to play.
        price_limits[selling_session] = expected_values[selling_session]

    else:
        # We are given a selling price of P. If the value generated by that price is higher or equal to the expected value
        # of going to the next selling session, then we sell now. Otherwise, we wait for a better price.
        expected_values[selling_session] = (
            expected_sell_from_price_to_price(
                price_limits[selling_session + 1], MAX_PRICE
            )
            + sum_of_probas_from_price_to_price(
                MIN_PRICE, price_limits[selling_session + 1] - 1
            )
            * expected_values[selling_session + 1]
        )


def main():
    sum_of_probas_from_price_to_price(1, 10)
    for selling_session in range(NB_SELLING_SESSIONS, 0, -1):
        calculate_selling_session(selling_session)


if __name__ == "__main__":
    print("Start")
    main()
