# coding: utf-8
import math

NB_SELLING_SESSIONS = 12
NB_BUYING_SESSIONS = 4
MAX_PRICE = 120
MIN_PRICE = 80
expected_values = {}
price_limits = {}
expected_values_buy = {}
price_limits_buy = {}

"""
Convention 1: since we're working with integers, equalities are likely and annoying to specify on every calculation. 
We will take action a guaranteed action (sell of buy) has the exact same value as going into the next session, we will always prefer
taking the saif action.

Convention 2: since it's more profitable to bulk buy/sell, we'll assume we're buying/selling only 1 turnip.
This is just a simplification to avoid trailing a NUMBER_OF_TURNIPS variable everywhere.
"""


def proba_of_price(price):
    return 1.0 / (MAX_PRICE - MIN_PRICE + 1)


def sum_of_probas_from_price_to_price(starting_price, ending_price):
    """Returns the probability of a random price being between inclusive
    starting_price and inclusive ending_price.

    Prices are integers.
    """
    sum = 0
    for i in range(int(starting_price), int(ending_price + 1)):
        sum += proba_of_price(i)
    return sum


def expected_sell_from_price_to_price(starting_price, ending_price):
    """Returns the expected value of the sell if the price is between inclusive
    starting_price and inclusive ending_price.

    Prices are integers.
    """
    sum = 0
    for i in range(int(starting_price), int(ending_price + 1)):
        # print("i = {}, proba of i = {}".format(i, proba_of_price(i)))
        sum += proba_of_price(i) * i
    return sum


def calculate_selling_session(selling_session):
    """Calculates the optimal play for every session, starting from the last
    one.

    Returns the everage selling value achieved with this strategy.
    """
    print("## Calculating selling session number {}".format(selling_session))
    if selling_session == NB_SELLING_SESSIONS:
        print("  This is the last selling session, we must sell no matter what")
        expected_values[selling_session] = expected_sell_from_price_to_price(
            MIN_PRICE, MAX_PRICE
        )
        # Expected value = selling value here "price_limits" are the equivalent selling prices that would make selling and waiting equivalent,
        # expected value wise, for a given session. These price_limits are lower on the last sessions and higher on the first sessions.
        # Intuitively this means that we can afford rolling the dice more often when we have lots of turns to play.
        price_limits[selling_session] = expected_values[selling_session]

    else:
        # We are given a selling price of P. If the value generated by that price is higher or equal to the expected value
        # of going to the next selling session, then we sell now. Otherwise, we wait for a better price.
        expected_values[selling_session] = (
            expected_sell_from_price_to_price(
                price_limits[selling_session + 1], MAX_PRICE
            )
            + sum_of_probas_from_price_to_price(
                MIN_PRICE, price_limits[selling_session + 1] - 1
            )
            * expected_values[selling_session + 1]
        )
        # Expected value = selling value here
        price_limits[selling_session] = expected_values[selling_session]
        print("  We must sell if the price is higher than {:.2f}".format(price_limits[selling_session + 1]))
    print("  Our expected sell value for this round is {:.2f}".format(expected_values[selling_session]))
    return expected_values[selling_session]

def calculate_buying_session(buying_session, selling_price):
    """Calculates the optimal play for every session, starting from the last
    one.

    Returns the everage buying value achieved with this strategy.
    """
    print("## Calculating buying session number {}".format(buying_session))
    if buying_session == NB_BUYING_SESSIONS:
        print("  This is the last buying session, we buy only if the price is better than our estimation of the selling value: {:.2f}".format(selling_price))
        proba_of_buying = sum_of_probas_from_price_to_price(MIN_PRICE, selling_price)
        print("Proba of buying in the last round {:.2f}".format(proba_of_buying))
        expected_values_buy[buying_session] = expected_sell_from_price_to_price(
            MIN_PRICE, selling_price
        )*1.0/(proba_of_buying)
        # Using the same function that were used for selling, but the names are not accurate anymore :/ TODO
        price_limits_buy[buying_session] = expected_values_buy[buying_session]

    else:
        # We are given a buying price of P. If the value generated by that price is higher or equal to the expected value
        # of going to the next buying session, then we buy now. Otherwise, we wait for a better price.
        expected_values_buy[buying_session] = (
            expected_sell_from_price_to_price(
                MIN_PRICE, price_limits_buy[buying_session + 1]
            )
            + sum_of_probas_from_price_to_price(
                price_limits_buy[buying_session + 1]+1, MAX_PRICE
            )
            * expected_values_buy[buying_session + 1]
        )
        # Expected value = selling value here
        price_limits_buy[buying_session] = expected_values_buy[buying_session]
        print("  We must buy if the price is lower than {:.2f}".format(price_limits_buy[buying_session + 1]))
    print("  Our expected buy value for this round is {:.2f}".format(expected_values_buy[buying_session]))
    return expected_values_buy[buying_session]

def calculate_selling_sessions() :
    """Calculates the optimal play for every session, starting from the last
    one.

    Returns the everage selling value achieved with this strategy.
    """
    for selling_session in range(NB_SELLING_SESSIONS, 0, -1):
        expected_value = calculate_selling_session(selling_session)
    return expected_value

def calculate_buying_sessions(selling_price) :
    """Calculates the optimal play for every session, starting from the last
    one."""
    for buying_session in range(NB_BUYING_SESSIONS, 0, -1):
        expected_value = calculate_buying_session(buying_session, selling_price)
    return expected_value

def main():
    selling_price = calculate_selling_sessions()
    print("\nThe average selling price will be {:.2f}\n".format(selling_price))
    buying_price = calculate_buying_sessions(selling_price)
    print("\nThe average buying price will be {:.2f}\n".format(buying_price))
    print("\nThe average gain per turnip is {:.2f}\n".format(selling_price-buying_price))




if __name__ == "__main__":
    print("Start")
    main()
